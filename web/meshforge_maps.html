<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MeshForge Maps</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', -apple-system, system-ui, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #map { width: 100vw; height: 100vh; z-index: 1; }

        /* Header bar */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: rgba(10, 14, 26, 0.92);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(79, 195, 247, 0.15);
            display: flex;
            align-items: center;
            padding: 0 16px;
            z-index: 1000;
            gap: 16px;
        }

        .header-title {
            font-size: 16px;
            font-weight: 600;
            color: #4fc3f7;
            white-space: nowrap;
        }

        .header-subtitle {
            font-size: 11px;
            color: #78909c;
            white-space: nowrap;
        }

        .header-stats {
            margin-left: auto;
            display: flex;
            gap: 16px;
            font-size: 12px;
            color: #90a4ae;
        }

        .stat-badge {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .stat-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }

        /* Control panel */
        .control-panel {
            position: fixed;
            top: 60px;
            right: 12px;
            width: 260px;
            background: rgba(10, 14, 26, 0.94);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(79, 195, 247, 0.12);
            border-radius: 8px;
            z-index: 1000;
            padding: 12px;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
        }

        .panel-section {
            margin-bottom: 14px;
        }

        .panel-section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            color: #4fc3f7;
            letter-spacing: 0.8px;
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(79, 195, 247, 0.1);
        }

        /* Layer toggles */
        .layer-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
            cursor: pointer;
            user-select: none;
        }

        .layer-toggle input[type="checkbox"] {
            accent-color: #4fc3f7;
            width: 14px;
            height: 14px;
        }

        .layer-color {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .layer-label {
            font-size: 13px;
            flex: 1;
        }

        .layer-count {
            font-size: 11px;
            color: #78909c;
        }

        /* Map style selector */
        .map-style-select {
            width: 100%;
            padding: 6px 8px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(79, 195, 247, 0.15);
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 12px;
            cursor: pointer;
        }

        .map-style-select option {
            background: #1a1f2e;
            color: #e0e0e0;
        }

        /* Space weather widget */
        .weather-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .weather-item {
            background: rgba(255, 255, 255, 0.04);
            border-radius: 4px;
            padding: 6px 8px;
            text-align: center;
        }

        .weather-value {
            font-size: 16px;
            font-weight: 600;
            color: #4fc3f7;
        }

        .weather-label {
            font-size: 10px;
            color: #78909c;
            text-transform: uppercase;
        }

        .band-conditions {
            text-align: center;
            padding: 6px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            margin-top: 6px;
        }

        .band-excellent { background: rgba(102, 187, 106, 0.2); color: #66bb6a; }
        .band-good { background: rgba(102, 187, 106, 0.15); color: #81c784; }
        .band-fair { background: rgba(255, 167, 38, 0.2); color: #ffa726; }
        .band-poor { background: rgba(239, 83, 80, 0.2); color: #ef5350; }
        .band-unknown { background: rgba(120, 144, 156, 0.2); color: #78909c; }

        /* VOACAP band prediction bars */
        .voacap-band-row {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 3px 0;
            font-size: 11px;
        }
        .voacap-band-label {
            width: 32px;
            color: #90a4ae;
            text-align: right;
            flex-shrink: 0;
        }
        .voacap-bar-bg {
            flex: 1;
            height: 14px;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }
        .voacap-bar-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.5s ease;
        }
        .voacap-bar-text {
            width: 32px;
            text-align: right;
            flex-shrink: 0;
            font-size: 10px;
            color: #78909c;
        }
        .voacap-fill-excellent { background: #66bb6a; }
        .voacap-fill-good { background: #81c784; }
        .voacap-fill-fair { background: #ffa726; }
        .voacap-fill-poor { background: #ef5350; }
        .voacap-fill-closed { background: #546e7a; }

        .voacap-snr-text {
            width: 42px;
            text-align: left;
            flex-shrink: 0;
            font-size: 10px;
            color: #546e7a;
        }

        /* Node health badge in popup */
        .health-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .health-excellent { background: rgba(102, 187, 106, 0.2); color: #66bb6a; }
        .health-good { background: rgba(129, 199, 132, 0.2); color: #81c784; }
        .health-fair { background: rgba(255, 167, 38, 0.2); color: #ffa726; }
        .health-poor { background: rgba(239, 83, 80, 0.2); color: #ef5350; }
        .health-critical { background: rgba(239, 83, 80, 0.3); color: #e53935; }
        .health-unknown { background: rgba(120, 144, 156, 0.2); color: #78909c; }

        /* DE/DX station info */
        .station-info {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            font-size: 11px;
        }
        .station-box {
            flex: 1;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 4px;
            padding: 6px 8px;
            text-align: center;
        }
        .station-label {
            font-size: 9px;
            color: #78909c;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .station-call {
            font-size: 13px;
            font-weight: 600;
            color: #42a5f5;
        }
        .station-grid {
            font-size: 10px;
            color: #90a4ae;
        }

        /* DX spots list */
        .dxspot-list {
            max-height: 120px;
            overflow-y: auto;
            font-size: 10px;
        }
        .dxspot-row {
            display: flex;
            gap: 4px;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }
        .dxspot-call { color: #42a5f5; font-weight: 600; min-width: 60px; }
        .dxspot-freq { color: #ffa726; min-width: 50px; }
        .dxspot-de { color: #90a4ae; min-width: 50px; }
        .dxspot-time { color: #546e7a; }

        /* HamClock source indicator */
        .hamclock-source {
            font-size: 10px;
            color: #546e7a;
            text-align: center;
            margin-top: 4px;
        }
        .hamclock-source-active { color: #42a5f5; }
        .hamclock-source-fallback { color: #ffa726; }

        /* Leaflet popup overrides for dark theme */
        .leaflet-popup-content-wrapper {
            background: rgba(10, 14, 26, 0.95) !important;
            color: #e0e0e0 !important;
            border: 1px solid rgba(79, 195, 247, 0.2) !important;
            border-radius: 6px !important;
        }

        .leaflet-popup-tip {
            background: rgba(10, 14, 26, 0.95) !important;
            border: 1px solid rgba(79, 195, 247, 0.2) !important;
        }

        .leaflet-popup-content {
            font-size: 12px;
            line-height: 1.5;
        }

        .popup-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .popup-network {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .popup-row {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
        }

        .popup-key { color: #78909c; }
        .popup-val { color: #e0e0e0; font-weight: 500; }

        /* Override marker cluster colors */
        .marker-cluster-small {
            background-color: rgba(79, 195, 247, 0.3) !important;
        }
        .marker-cluster-small div {
            background-color: rgba(79, 195, 247, 0.6) !important;
            color: #fff !important;
        }
        .marker-cluster-medium {
            background-color: rgba(79, 195, 247, 0.4) !important;
        }
        .marker-cluster-medium div {
            background-color: rgba(79, 195, 247, 0.7) !important;
            color: #fff !important;
        }
        .marker-cluster-large {
            background-color: rgba(79, 195, 247, 0.5) !important;
        }
        .marker-cluster-large div {
            background-color: rgba(79, 195, 247, 0.8) !important;
            color: #fff !important;
        }

        /* Toggle panel button (mobile) */
        .toggle-panel-btn {
            display: none;
            position: fixed;
            top: 56px;
            right: 12px;
            z-index: 1001;
            background: rgba(10, 14, 26, 0.9);
            border: 1px solid rgba(79, 195, 247, 0.2);
            color: #4fc3f7;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
        }

        @media (max-width: 768px) {
            .control-panel { display: none; }
            .toggle-panel-btn { display: block; }
            .control-panel.visible { display: block; width: calc(100vw - 24px); }
        }

        /* Leaflet control overrides */
        .leaflet-control-zoom a {
            background: rgba(10, 14, 26, 0.9) !important;
            color: #4fc3f7 !important;
            border-color: rgba(79, 195, 247, 0.2) !important;
        }

        .leaflet-control-attribution {
            background: rgba(10, 14, 26, 0.8) !important;
            color: #546e7a !important;
            font-size: 10px !important;
        }

        .leaflet-control-attribution a {
            color: #78909c !important;
        }

        /* Solar terminator overlay */
        .terminator-overlay {
            fill: rgba(0, 0, 0, 0.35);
            stroke: rgba(255, 193, 7, 0.4);
            stroke-width: 1.5;
        }

        /* Connection status indicator */
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
            white-space: nowrap;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .status-connected .status-dot { background: #66bb6a; }
        .status-connected { color: #66bb6a; }
        .status-loading .status-dot { background: #ffa726; animation: pulse 1s infinite; }
        .status-loading { color: #ffa726; }
        .status-error .status-dot { background: #ef5350; }
        .status-error { color: #ef5350; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(10, 14, 26, 0.95);
            border: 1px solid rgba(79, 195, 247, 0.3);
            color: #e0e0e0;
            padding: 8px 20px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 2000;
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            pointer-events: none;
        }

        .toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.toast-error {
            border-color: rgba(239, 83, 80, 0.4);
            color: #ef5350;
        }

        /* Stale/offline node visual indicator */
        .node-marker-stale {
            opacity: 0.4;
            filter: grayscale(60%);
        }

        /* Node history panel */
        .history-panel {
            position: fixed;
            bottom: 24px;
            left: 12px;
            width: 320px;
            max-height: 300px;
            background: rgba(10, 14, 26, 0.94);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(79, 195, 247, 0.12);
            border-radius: 8px;
            z-index: 1000;
            padding: 12px;
            overflow-y: auto;
            display: none;
        }

        .history-panel-title {
            font-size: 12px;
            font-weight: 600;
            color: #4fc3f7;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-close-btn {
            background: none;
            border: none;
            color: #78909c;
            cursor: pointer;
            font-size: 14px;
            padding: 0 4px;
        }

        .history-close-btn:hover { color: #ef5350; }

        .history-node-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .history-node-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            cursor: pointer;
            font-size: 11px;
        }

        .history-node-row:hover { background: rgba(79, 195, 247, 0.06); }

        .history-node-id { color: #42a5f5; font-weight: 500; }
        .history-node-count { color: #78909c; }

        .trajectory-btn {
            font-size: 10px;
            background: rgba(79, 195, 247, 0.15);
            border: 1px solid rgba(79, 195, 247, 0.3);
            color: #4fc3f7;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
        }

        .trajectory-btn:hover { background: rgba(79, 195, 247, 0.25); }
        .trajectory-btn.active { background: rgba(79, 195, 247, 0.35); color: #fff; }

        /* Refresh button states */
        .refresh-btn {
            width: 100%;
            padding: 6px;
            background: rgba(79, 195, 247, 0.1);
            border: 1px solid rgba(79, 195, 247, 0.2);
            color: #4fc3f7;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .refresh-btn:hover { background: rgba(79, 195, 247, 0.2); }

        .refresh-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Last-updated text */
        .last-updated {
            font-size: 10px;
            color: #546e7a;
            text-align: center;
            margin-top: 6px;
        }
    </style>
</head>
<body>

<div class="header">
    <span class="header-title">MeshForge Maps</span>
    <span class="header-subtitle" id="headerSubtitle">Multi-Source Mesh Network Map</span>
    <div class="header-stats" id="headerStats">
        <span class="status-indicator status-loading" id="connStatus">
            <span class="status-dot"></span>
            <span id="connLabel">Loading</span>
        </span>
        <span class="stat-badge">
            <span class="stat-dot" style="background:#66bb6a"></span>
            <span id="statMeshtastic">0</span> Meshtastic
        </span>
        <span class="stat-badge">
            <span class="stat-dot" style="background:#ab47bc"></span>
            <span id="statReticulum">0</span> RNS
        </span>
        <span class="stat-badge">
            <span class="stat-dot" style="background:#ff7043"></span>
            <span id="statAredn">0</span> AREDN
        </span>
        <span class="stat-badge" id="mqttBadge" style="display:none">
            <span class="stat-dot" style="background:#42a5f5"></span>
            MQTT <span id="statMqtt">0</span>
        </span>
    </div>
</div>

<button class="toggle-panel-btn" onclick="togglePanel()">Controls</button>

<div class="control-panel" id="controlPanel">
    <div class="panel-section">
        <div class="panel-section-title">Map Style</div>
        <select class="map-style-select" id="tileSelect" onchange="changeTileLayer()">
            <!-- Populated dynamically -->
        </select>
    </div>

    <div class="panel-section">
        <div class="panel-section-title">Network Layers</div>
        <label class="layer-toggle">
            <input type="checkbox" id="layerMeshtastic" checked onchange="toggleLayer('meshtastic')">
            <span class="layer-color" style="background:#66bb6a"></span>
            <span class="layer-label">Meshtastic</span>
            <span class="layer-count" id="countMeshtastic">0</span>
        </label>
        <label class="layer-toggle">
            <input type="checkbox" id="layerReticulum" checked onchange="toggleLayer('reticulum')">
            <span class="layer-color" style="background:#ab47bc"></span>
            <span class="layer-label">Reticulum / RMAP</span>
            <span class="layer-count" id="countReticulum">0</span>
        </label>
        <label class="layer-toggle">
            <input type="checkbox" id="layerAredn" checked onchange="toggleLayer('aredn')">
            <span class="layer-color" style="background:#ff7043"></span>
            <span class="layer-label">AREDN</span>
            <span class="layer-count" id="countAredn">0</span>
        </label>
    </div>

    <div class="panel-section">
        <div class="panel-section-title">Overlays</div>
        <label class="layer-toggle">
            <input type="checkbox" id="overlayTerminator" checked onchange="toggleTerminator()">
            <span class="layer-color" style="background:#ffc107"></span>
            <span class="layer-label">Solar Terminator</span>
        </label>
        <label class="layer-toggle">
            <input type="checkbox" id="overlayClustering" checked onchange="toggleClustering()">
            <span class="layer-color" style="background:#4fc3f7"></span>
            <span class="layer-label">Marker Clustering</span>
        </label>
        <label class="layer-toggle">
            <input type="checkbox" id="overlayTopology" onchange="toggleTopology()">
            <span class="layer-color" style="background:#29b6f6"></span>
            <span class="layer-label">Topology Links</span>
            <span class="layer-count" id="countLinks">0</span>
        </label>
        <label class="layer-toggle">
            <input type="checkbox" id="overlayTrajectory" onchange="toggleTrajectoryPanel()">
            <span class="layer-color" style="background:#ffc107"></span>
            <span class="layer-label">Node History</span>
        </label>
        <label class="layer-toggle">
            <input type="checkbox" id="overlayHealth" onchange="toggleHealthOverlay()">
            <span class="layer-color" style="background:#e91e63"></span>
            <span class="layer-label">Node Health</span>
        </label>
    </div>

    <div class="panel-section" id="weatherSection">
        <div class="panel-section-title">Space Weather</div>
        <div class="weather-grid">
            <div class="weather-item">
                <div class="weather-value" id="wxSFI">--</div>
                <div class="weather-label">SFI</div>
            </div>
            <div class="weather-item">
                <div class="weather-value" id="wxKp">--</div>
                <div class="weather-label">Kp Index</div>
            </div>
            <div class="weather-item">
                <div class="weather-value" id="wxWind">--</div>
                <div class="weather-label">Solar Wind</div>
            </div>
            <div class="weather-item">
                <div class="weather-value" id="wxBand">--</div>
                <div class="weather-label">HF Cond.</div>
            </div>
        </div>
        <div class="band-conditions band-unknown" id="bandBar">
            Band Conditions: Loading...
        </div>
    </div>

    <div class="panel-section" id="hamclockSection" style="display:none">
        <div class="panel-section-title">Propagation</div>
        <div class="station-info" id="stationInfo" style="display:none">
            <div class="station-box">
                <div class="station-label">DE (Home)</div>
                <div class="station-call" id="deCall">--</div>
                <div class="station-grid" id="deGrid">--</div>
            </div>
            <div class="station-box">
                <div class="station-label">DX (Target)</div>
                <div class="station-call" id="dxCall">--</div>
                <div class="station-grid" id="dxGrid">--</div>
            </div>
        </div>
        <div id="voacapBands" style="margin-top:6px"></div>
        <div id="dxspotContainer" style="margin-top:8px;display:none">
            <div style="font-size:10px;color:#78909c;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:4px">DX Spots</div>
            <div class="dxspot-list" id="dxspotList"></div>
        </div>
        <div class="hamclock-source" id="hamclockSource">--</div>
    </div>

    <div class="panel-section">
        <div class="panel-section-title">Data</div>
        <button class="refresh-btn" id="refreshBtn" onclick="refreshData()">
            Refresh All Sources
        </button>
        <div class="last-updated" id="lastUpdated">Not yet loaded</div>
    </div>
</div>

<div id="map"></div>

<div class="history-panel" id="historyPanel">
    <div class="history-panel-title">
        <span>Node History</span>
        <button class="history-close-btn" onclick="toggleTrajectoryPanel()">&times;</button>
    </div>
    <div class="history-node-list" id="historyNodeList">
        <div style="color:#546e7a;font-size:11px;text-align:center;padding:12px">Loading tracked nodes...</div>
    </div>
</div>

<div class="toast" id="toast"></div>

<script>
    // =========================================================================
    // MeshForge Maps - Leaflet Frontend
    // =========================================================================

    const API_BASE = window.location.origin;

    // Fetch with retry (exponential backoff) for API resilience
    async function fetchWithRetry(url, retries, baseDelay) {
        retries = retries || 2;
        baseDelay = baseDelay || 1000;
        for (let attempt = 0; attempt <= retries; attempt++) {
            try {
                const resp = await fetch(url);
                if (resp.ok) return resp;
                if (resp.status >= 500 && attempt < retries) {
                    await new Promise(r => setTimeout(r, baseDelay * Math.pow(2, attempt)));
                    continue;
                }
                return resp; // Return non-retryable errors as-is
            } catch (e) {
                if (attempt >= retries) throw e;
                await new Promise(r => setTimeout(r, baseDelay * Math.pow(2, attempt)));
            }
        }
    }

    // Network colors (matches meshforge core palette)
    const NETWORK_COLORS = {
        meshtastic: '#66bb6a',
        reticulum: '#ab47bc',
        aredn:     '#ff7043',
        hamclock:  '#42a5f5',
    };

    // Tile provider definitions (loaded from server, with fallback)
    let TILE_PROVIDERS = {
        carto_dark: {
            name: 'CartoDB Dark Matter',
            url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
            attribution: '&copy; OSM &copy; CARTO',
            max_zoom: '20',
        },
        osm_standard: {
            name: 'OpenStreetMap',
            url: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
            attribution: '&copy; OpenStreetMap contributors',
            max_zoom: '19',
        },
        osm_topo: {
            name: 'OpenTopoMap',
            url: 'https://tile.opentopomap.org/{z}/{x}/{y}.png',
            attribution: '&copy; OpenTopoMap (CC-BY-SA)',
            max_zoom: '17',
        },
        esri_satellite: {
            name: 'Esri Satellite',
            url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
            attribution: '&copy; Esri, Maxar, Earthstar',
            max_zoom: '19',
        },
        esri_topo: {
            name: 'Esri Topographic',
            url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}',
            attribution: '&copy; Esri, HERE, Garmin',
            max_zoom: '19',
        },
        stadia_terrain: {
            name: 'Stadia Terrain',
            url: 'https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}.png',
            attribution: '&copy; Stadia Maps &copy; Stamen Design',
            max_zoom: '18',
        },
    };

    // =========================================================================
    // State
    // =========================================================================

    let map;
    let currentTileLayer;
    let clusterGroup;
    let directGroup;        // non-clustered layer group
    let terminatorLayer;
    let topologyLayer;      // Leaflet GeoJSON layer for topology links
    let showTopology = false;
    let useClustering = true;
    let isLoading = false;
    let lastOverlayData = null;  // cached overlay from last successful fetch
    let consecutiveErrors = 0;
    let ws = null;               // WebSocket connection (real-time updates)
    let wsReconnectTimer = null; // Timer for WebSocket reconnect attempts
    let wsReconnectDelay = 2000; // Current reconnect delay (exponential backoff)
    let trajectoryLayers = {};   // Active trajectory polylines keyed by node_id
    const MAX_TRAJECTORIES = 20; // Cap to prevent unbounded memory growth
    let historyPanelOpen = false;
    let healthOverlayActive = false;  // Whether health color-coding is enabled
    let nodeHealthScores = {};        // Cached {node_id: {score, status}} from API

    // Per-network layer groups (for toggle visibility)
    const networkLayers = {
        meshtastic: [],
        reticulum: [],
        aredn: [],
    };
    const networkVisible = {
        meshtastic: true,
        reticulum: true,
        aredn: true,
    };
    let allFeatures = [];

    // =========================================================================
    // Initialization
    // =========================================================================

    function initMap() {
        map = L.map('map', {
            center: [20, -100],
            zoom: 4,
            zoomControl: true,
            attributionControl: true,
        });

        // Default tile layer
        currentTileLayer = L.tileLayer(TILE_PROVIDERS.carto_dark.url, {
            attribution: TILE_PROVIDERS.carto_dark.attribution,
            maxZoom: parseInt(TILE_PROVIDERS.carto_dark.max_zoom),
        }).addTo(map);

        // Cluster group
        clusterGroup = L.markerClusterGroup({
            maxClusterRadius: 50,
            spiderfyOnMaxZoom: true,
            showCoverageOnHover: false,
            zoomToBoundsOnClick: true,
            iconCreateFunction: function(cluster) {
                const count = cluster.getChildCount();
                let size = 'small';
                if (count > 50) size = 'large';
                else if (count > 10) size = 'medium';
                return L.divIcon({
                    html: '<div>' + count + '</div>',
                    className: 'marker-cluster marker-cluster-' + size,
                    iconSize: L.point(40, 40),
                });
            },
        }).addTo(map);

        directGroup = L.layerGroup();

        // Populate tile selector
        populateTileSelector();

        // Load configuration from server
        loadConfig();

        // Load node data
        loadNodeData();

        // Shift map down for header
        map.getContainer().style.marginTop = '48px';
        map.getContainer().style.height = 'calc(100vh - 48px)';
        map.invalidateSize();
    }

    async function loadConfig() {
        try {
            const resp = await fetch(API_BASE + '/api/tile-providers');
            if (resp.ok) {
                const providers = await resp.json();
                if (Object.keys(providers).length > 0) {
                    TILE_PROVIDERS = providers;
                    populateTileSelector();
                }
            }
        } catch (e) {
            console.debug('Using built-in tile providers');
        }

        try {
            const resp = await fetch(API_BASE + '/api/config');
            if (resp.ok) {
                const config = await resp.json();
                if (config.map_center_lat && config.map_center_lon) {
                    map.setView(
                        [config.map_center_lat, config.map_center_lon],
                        config.map_default_zoom || 4
                    );
                }
                if (config.default_tile_provider && TILE_PROVIDERS[config.default_tile_provider]) {
                    document.getElementById('tileSelect').value = config.default_tile_provider;
                    changeTileLayer();
                }
                // Connect WebSocket for real-time updates
                if (config.ws_port) {
                    connectWebSocket(config.ws_port);
                }
                // Fetch version from status endpoint (upstream: version badge)
                fetchVersion();
            }
        } catch (e) {
            console.debug('Using default config');
        }
    }

    async function fetchVersion() {
        try {
            const resp = await fetch(API_BASE + '/api/status');
            if (resp.ok) {
                const status = await resp.json();
                if (status.version) {
                    var sub = document.getElementById('headerSubtitle');
                    if (sub) sub.textContent = 'v' + status.version;
                }
                // Show MQTT live node count in header (upstream: monitoring)
                if (status.mqtt_live === 'connected' && status.mqtt_node_count > 0) {
                    var badge = document.getElementById('mqttBadge');
                    var count = document.getElementById('statMqtt');
                    if (badge) badge.style.display = '';
                    if (count) count.textContent = status.mqtt_node_count;
                }
            }
        } catch (e) {
            // Non-critical, silently ignore
        }
    }

    function populateTileSelector() {
        const select = document.getElementById('tileSelect');
        select.innerHTML = '';
        for (const [key, provider] of Object.entries(TILE_PROVIDERS)) {
            const opt = document.createElement('option');
            opt.value = key;
            opt.textContent = provider.name;
            select.appendChild(opt);
        }
    }

    // =========================================================================
    // Connection Status & Notifications
    // =========================================================================

    function setConnectionStatus(status, label) {
        const el = document.getElementById('connStatus');
        const labelEl = document.getElementById('connLabel');
        el.className = 'status-indicator status-' + status;
        labelEl.textContent = label || status;
    }

    function showToast(message, isError) {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.className = 'toast' + (isError ? ' toast-error' : '') + ' visible';
        clearTimeout(toast._timer);
        toast._timer = setTimeout(function() {
            toast.className = 'toast';
        }, 3000);
    }

    function updateLastUpdated() {
        const el = document.getElementById('lastUpdated');
        if (el) {
            el.textContent = 'Updated: ' + new Date().toLocaleTimeString();
        }
    }

    // =========================================================================
    // Data Loading
    // =========================================================================

    async function loadNodeData() {
        if (isLoading) return;  // prevent concurrent fetches
        isLoading = true;
        setConnectionStatus('loading', 'Loading');
        const btn = document.getElementById('refreshBtn');
        if (btn) btn.disabled = true;

        try {
            const resp = await fetchWithRetry(API_BASE + '/api/nodes/geojson', 2, 1000);
            if (!resp.ok) throw new Error('HTTP ' + resp.status);
            const data = await resp.json();
            processGeoJSON(data);
            setConnectionStatus('connected', 'Connected');
            updateLastUpdated();
            consecutiveErrors = 0;
            // Load HamClock propagation data (non-blocking)
            loadHamClockData();
        } catch (e) {
            consecutiveErrors++;
            console.error('Failed to load node data:', e);
            setConnectionStatus('error', 'Error');
            if (consecutiveErrors === 1) {
                showToast('Failed to load node data: ' + e.message, true);
            } else if (consecutiveErrors === 3) {
                showToast('Server unreachable after 3 attempts', true);
            }
        } finally {
            isLoading = false;
            if (btn) btn.disabled = false;
        }
    }

    function renderMarkers() {
        // Core marker rendering from allFeatures â€” single source of truth
        // for both initial load (processGeoJSON) and re-render (health overlay toggle)
        clusterGroup.clearLayers();
        directGroup.clearLayers();

        const counts = { meshtastic: 0, reticulum: 0, aredn: 0 };
        networkLayers.meshtastic = [];
        networkLayers.reticulum = [];
        networkLayers.aredn = [];

        for (const feature of allFeatures) {
            const props = feature.properties || {};
            const coords = feature.geometry?.coordinates;
            if (!coords || coords.length < 2) continue;

            const lat = coords[1];
            const lon = coords[0];
            const network = props.network || 'unknown';

            // Determine color: health overlay or network color
            let color;
            if (healthOverlayActive) {
                color = getHealthColor(props.id) || '#78909c';
            } else {
                color = NETWORK_COLORS[network] || '#78909c';
            }

            const isStale = props.is_online === false;
            const marker = L.circleMarker([lat, lon], {
                radius: isStale ? 5 : 7,
                fillColor: color,
                color: isStale ? '#546e7a' : color,
                weight: isStale ? 1 : 2,
                opacity: isStale ? 0.4 : 1.0,
                fillOpacity: isStale ? 0.2 : 0.7,
            });

            marker.bindPopup(buildPopup(props, color));

            if (counts.hasOwnProperty(network)) {
                counts[network]++;
                networkLayers[network].push(marker);
            }

            if (networkVisible[network] !== false) {
                if (useClustering) {
                    clusterGroup.addLayer(marker);
                } else {
                    directGroup.addLayer(marker);
                }
            }
        }

        document.getElementById('countMeshtastic').textContent = counts.meshtastic;
        document.getElementById('countReticulum').textContent = counts.reticulum;
        document.getElementById('countAredn').textContent = counts.aredn;
        document.getElementById('statMeshtastic').textContent = counts.meshtastic;
        document.getElementById('statReticulum').textContent = counts.reticulum;
        document.getElementById('statAredn').textContent = counts.aredn;
    }

    function processGeoJSON(data) {
        allFeatures = data.features || [];
        renderMarkers();

        // Process overlay data (space weather, terminator)
        const overlayData = data.properties?.overlay_data || {};
        if (overlayData && Object.keys(overlayData).length > 0) {
            lastOverlayData = overlayData;
        }
        updateSpaceWeather(overlayData.space_weather);
        if (document.getElementById('overlayTerminator').checked) {
            updateTerminator(overlayData.solar_terminator);
        }
    }

    function buildPopup(props, color) {
        const rows = [];

        // Helper: only add row if value is defined and non-empty
        function addRow(label, value, suffix) {
            if (value != null && value !== '') {
                const display = suffix ? esc(String(value)) + suffix : esc(String(value));
                rows.push(`<div class="popup-row"><span class="popup-key">${esc(label)}</span><span class="popup-val">${display}</span></div>`);
            }
        }

        addRow('Type', props.node_type, '');
        addRow('Hardware', props.hardware, '');
        addRow('Role', props.role, '');

        // Relay indicator
        if (props.is_relay) {
            rows.push(`<div class="popup-row"><span class="popup-key">Relay</span><span class="popup-val" style="color:#ffa726">Yes</span></div>`);
        }
        if (props.via_mqtt) {
            rows.push(`<div class="popup-row"><span class="popup-key">Via</span><span class="popup-val" style="color:#42a5f5">MQTT</span></div>`);
        }

        if (props.battery != null) addRow('Battery', props.battery, '%');
        if (props.voltage != null) addRow('Voltage', Number(props.voltage).toFixed(2), 'V');
        if (props.snr != null) addRow('SNR', props.snr, ' dB');
        if (props.rssi != null) addRow('RSSI', props.rssi, ' dBm');
        if (props.altitude != null) addRow('Altitude', props.altitude, 'm');
        if (props.hops_away != null) addRow('Hops', props.hops_away, '');

        // Channel utilization warning (upstream improvement)
        if (props.channel_util != null) {
            const cu = Number(props.channel_util);
            const cuColor = cu > 50 ? '#ef5350' : cu > 25 ? '#ffa726' : '#66bb6a';
            rows.push(`<div class="popup-row"><span class="popup-key">Ch Util</span><span class="popup-val" style="color:${cuColor}">${cu.toFixed(1)}%</span></div>`);
        }
        if (props.air_util_tx != null) {
            addRow('Air TX', Number(props.air_util_tx).toFixed(1), '%');
        }

        // Environmental sensors
        if (props.temperature != null) addRow('Temp', Number(props.temperature).toFixed(1), '\u00b0C');
        if (props.humidity != null) addRow('Humidity', Number(props.humidity).toFixed(0), '%');
        if (props.pressure != null) addRow('Pressure', Number(props.pressure).toFixed(1), ' hPa');
        addRow('Firmware', props.firmware, '');

        // AREDN link type indicator with color coding
        if (props.link_type) {
            const ltColor = props.link_type === 'RF' ? '#ff7043' :
                            props.link_type === 'DTD' ? '#66bb6a' :
                            props.link_type === 'TUN' ? '#42a5f5' :
                            props.link_type === 'XLINK' ? '#ab47bc' : '#78909c';
            rows.push(`<div class="popup-row"><span class="popup-key">Link</span><span class="popup-val" style="color:${ltColor}">${esc(props.link_type)}</span></div>`);
        }
        addRow('Info', props.description, '');

        const onlineStr = props.is_online === true ? 'Online' :
                          props.is_online === false ? 'Offline' : 'Unknown';
        const onlineColor = props.is_online === true ? '#66bb6a' :
                            props.is_online === false ? '#ef5350' : '#78909c';

        // Last-seen timestamp
        let lastSeenStr = '';
        if (props.last_seen) {
            try {
                const ts = typeof props.last_seen === 'number' ? new Date(props.last_seen * 1000) : new Date(props.last_seen);
                if (!isNaN(ts.getTime())) {
                    lastSeenStr = `<div class="popup-row" style="font-size:10px;color:#546e7a"><span class="popup-key">Seen</span><span class="popup-val">${ts.toLocaleString()}</span></div>`;
                }
            } catch (e) { /* ignore parse errors */ }
        }

        // Health score badge (if available)
        let healthBadge = '';
        const hs = nodeHealthScores[props.id];
        if (hs) {
            healthBadge = `<div class="popup-row"><span class="popup-key">Health</span><span class="popup-val"><span class="health-badge health-${hs.status}">${hs.score} ${hs.status}</span></span></div>`;
        }

        return `
            <div class="popup-title" style="color:${color}">${esc(props.name || props.id || 'Unknown')}</div>
            <div class="popup-network" style="color:${color}">${esc(props.network || '')} <span style="color:${onlineColor}">${onlineStr}</span></div>
            ${healthBadge}
            ${rows.join('')}
            ${lastSeenStr}
            <div class="popup-row" style="margin-top:4px;font-size:10px;color:#546e7a">
                <span>ID: ${esc(props.id || '')}</span>
            </div>
        `;
    }

    function esc(str) {
        if (!str) return '';
        const div = document.createElement('div');
        div.textContent = String(str);
        return div.innerHTML;
    }

    // =========================================================================
    // UI Controls
    // =========================================================================

    function changeTileLayer() {
        const key = document.getElementById('tileSelect').value;
        const provider = TILE_PROVIDERS[key];
        if (!provider) return;

        if (currentTileLayer) {
            map.removeLayer(currentTileLayer);
        }
        currentTileLayer = L.tileLayer(provider.url, {
            attribution: provider.attribution,
            maxZoom: parseInt(provider.max_zoom) || 19,
        }).addTo(map);
    }

    function toggleLayer(network) {
        const checkbox = document.getElementById('layer' + network.charAt(0).toUpperCase() + network.slice(1));
        networkVisible[network] = checkbox.checked;
        rebuildMarkers();
    }

    function toggleClustering() {
        useClustering = document.getElementById('overlayClustering').checked;
        rebuildMarkers();
    }

    function rebuildMarkers() {
        clusterGroup.clearLayers();
        directGroup.clearLayers();

        if (useClustering) {
            if (map.hasLayer(directGroup)) map.removeLayer(directGroup);
            if (!map.hasLayer(clusterGroup)) map.addLayer(clusterGroup);
        } else {
            if (map.hasLayer(clusterGroup)) map.removeLayer(clusterGroup);
            if (!map.hasLayer(directGroup)) map.addLayer(directGroup);
        }

        for (const network of Object.keys(networkLayers)) {
            if (!networkVisible[network]) continue;
            for (const marker of networkLayers[network]) {
                if (useClustering) {
                    clusterGroup.addLayer(marker);
                } else {
                    directGroup.addLayer(marker);
                }
            }
        }
    }

    async function toggleTerminator() {
        const show = document.getElementById('overlayTerminator').checked;
        if (show) {
            // Use cached overlay or fetch from lightweight overlay endpoint
            if (lastOverlayData && lastOverlayData.solar_terminator) {
                updateTerminator(lastOverlayData.solar_terminator);
            } else {
                try {
                    const resp = await fetch(API_BASE + '/api/overlay');
                    if (resp.ok) {
                        const overlay = await resp.json();
                        lastOverlayData = overlay;
                        updateTerminator(overlay.solar_terminator);
                    }
                } catch (e) {
                    console.debug('Overlay fetch failed:', e);
                }
            }
        } else if (terminatorLayer) {
            map.removeLayer(terminatorLayer);
            terminatorLayer = null;
        }
    }

    function togglePanel() {
        const panel = document.getElementById('controlPanel');
        panel.classList.toggle('visible');
    }

    async function refreshData() {
        showToast('Refreshing all sources...');
        await loadNodeData();
        if (showTopology) await loadTopologyData();
        if (consecutiveErrors === 0) {
            showToast('Data refreshed');
        }
    }

    // =========================================================================
    // Space Weather Display
    // =========================================================================

    function updateSpaceWeather(weather) {
        if (!weather) return;

        const sfiEl = document.getElementById('wxSFI');
        const kpEl = document.getElementById('wxKp');
        const windEl = document.getElementById('wxWind');
        const bandEl = document.getElementById('wxBand');
        const bandBar = document.getElementById('bandBar');

        if (weather.solar_flux) sfiEl.textContent = weather.solar_flux;
        if (weather.kp_index != null) kpEl.textContent = Number(weather.kp_index).toFixed(1);
        if (weather.solar_wind_speed) windEl.textContent = weather.solar_wind_speed;

        const cond = weather.band_conditions || 'unknown';
        bandEl.textContent = cond.charAt(0).toUpperCase() + cond.slice(1);

        bandBar.className = 'band-conditions band-' + cond;
        bandBar.textContent = 'Band Conditions: ' + cond.charAt(0).toUpperCase() + cond.slice(1);
    }

    // =========================================================================
    // HamClock Propagation Panel
    // =========================================================================

    async function loadHamClockData() {
        try {
            var resp = await fetch(API_BASE + '/api/hamclock');
            if (!resp.ok) {
                document.getElementById('hamclockSection').style.display = 'none';
                return;
            }
            var data = await resp.json();
            updateHamClockPanel(data);
        } catch (e) {
            console.debug('HamClock data unavailable:', e);
            document.getElementById('hamclockSection').style.display = 'none';
        }
    }

    function updateHamClockPanel(data) {
        var section = document.getElementById('hamclockSection');
        if (!data) { section.style.display = 'none'; return; }
        section.style.display = '';

        // Source indicator
        var srcEl = document.getElementById('hamclockSource');
        if (data.available) {
            var srcName = (data.source && data.source.indexOf('OpenHamClock') >= 0) ? 'OpenHamClock' : 'HamClock';
            srcEl.textContent = 'Source: ' + srcName + ' API (' + esc(data.host) + ':' + data.port + ')';
            srcEl.className = 'hamclock-source hamclock-source-active';
        } else {
            srcEl.textContent = 'Source: NOAA SWPC (OpenHamClock unavailable)';
            srcEl.className = 'hamclock-source hamclock-source-fallback';
        }

        // DE/DX Station info
        var stationEl = document.getElementById('stationInfo');
        if (data.de_station || data.dx_station) {
            stationEl.style.display = '';
            if (data.de_station) {
                document.getElementById('deCall').textContent = data.de_station.call || '--';
                document.getElementById('deGrid').textContent = data.de_station.grid || '--';
            }
            if (data.dx_station) {
                document.getElementById('dxCall').textContent = data.dx_station.call || '--';
                document.getElementById('dxGrid').textContent = data.dx_station.grid || '--';
            }
        } else {
            stationEl.style.display = 'none';
        }

        // VOACAP bands
        var voacapEl = document.getElementById('voacapBands');
        if (data.voacap && data.voacap.bands && Object.keys(data.voacap.bands).length > 0) {
            var html = '';
            var bandOrder = ['80m', '40m', '30m', '20m', '17m', '15m', '12m', '10m'];
            var bands = data.voacap.bands;
            for (var i = 0; i < bandOrder.length; i++) {
                var band = bandOrder[i];
                if (!bands[band]) continue;
                var info = bands[band];
                var rel = info.reliability || 0;
                var status = info.status || 'closed';
                var snrStr = (info.snr != null) ? info.snr + 'dB' : '';
                html += '<div class="voacap-band-row">' +
                    '<span class="voacap-band-label">' + esc(band) + '</span>' +
                    '<div class="voacap-bar-bg"><div class="voacap-bar-fill voacap-fill-' + status + '" style="width:' + rel + '%"></div></div>' +
                    '<span class="voacap-bar-text">' + rel + '%</span>' +
                    '<span class="voacap-snr-text">' + snrStr + '</span>' +
                    '</div>';
            }
            if (data.voacap.best_band) {
                html += '<div style="font-size:10px;color:#42a5f5;text-align:center;margin-top:4px">Best: ' + esc(data.voacap.best_band) + ' (' + (data.voacap.best_reliability || 0) + '%)</div>';
            }
            voacapEl.innerHTML = html;
        } else if (data.band_conditions && data.band_conditions.bands) {
            var html = '';
            var bc = data.band_conditions.bands;
            for (var key in bc) {
                html += '<div class="voacap-band-row">' +
                    '<span class="voacap-band-label">' + esc(key) + '</span>' +
                    '<span style="font-size:11px;color:#90a4ae">' + esc(bc[key]) + '</span>' +
                    '</div>';
            }
            voacapEl.innerHTML = html;
        } else {
            voacapEl.innerHTML = '';
        }

        // DX Spots
        var dxContainer = document.getElementById('dxspotContainer');
        var dxList = document.getElementById('dxspotList');
        if (data.dxspots && data.dxspots.length > 0) {
            dxContainer.style.display = '';
            var html = '';
            var spots = data.dxspots.slice(0, 10); // Show latest 10
            for (var i = 0; i < spots.length; i++) {
                var s = spots[i];
                html += '<div class="dxspot-row">' +
                    '<span class="dxspot-call">' + esc(s.dx_call) + '</span>' +
                    '<span class="dxspot-freq">' + esc(s.freq_khz) + '</span>' +
                    '<span class="dxspot-de">' + esc(s.de_call || '') + '</span>' +
                    '<span class="dxspot-time">' + esc(s.utc || '') + '</span>' +
                    '</div>';
            }
            dxList.innerHTML = html;
        } else {
            dxContainer.style.display = 'none';
        }
    }

    // =========================================================================
    // Solar Terminator
    // =========================================================================

    function updateTerminator(termData) {
        if (!termData) return;
        if (terminatorLayer) {
            map.removeLayer(terminatorLayer);
        }

        // Calculate terminator polygon from subsolar point
        const subLat = termData.subsolar_lat;
        const subLon = termData.subsolar_lon;
        const points = [];

        // Build the night-side polygon
        for (let lng = -180; lng <= 180; lng += 2) {
            const lngRad = lng * Math.PI / 180;
            const subLatRad = subLat * Math.PI / 180;
            const subLonRad = subLon * Math.PI / 180;

            // Solar zenith angle = 90 deg at terminator
            // latitude where sun is at horizon for this longitude
            const dLng = (lng - subLon) * Math.PI / 180;
            const terminatorLat = Math.atan(-Math.cos(dLng) / Math.tan(subLatRad)) * 180 / Math.PI;

            points.push([terminatorLat, lng]);
        }

        // Close the polygon on the dark side
        // Determine which pole is dark
        const darkPole = subLat > 0 ? -90 : 90;
        const nightPoly = [];

        // Top/bottom edge
        nightPoly.push([darkPole, -180]);
        for (const p of points) {
            nightPoly.push(p);
        }
        nightPoly.push([darkPole, 180]);
        nightPoly.push([darkPole, -180]);

        terminatorLayer = L.polygon(nightPoly, {
            color: 'rgba(255, 193, 7, 0.4)',
            fillColor: 'rgba(0, 0, 0, 0.3)',
            fillOpacity: 0.3,
            weight: 1.5,
            interactive: false,
        }).addTo(map);
    }

    // =========================================================================
    // Node Health Overlay
    // =========================================================================

    const HEALTH_COLORS = {
        excellent: '#66bb6a',
        good:      '#81c784',
        fair:      '#ffa726',
        poor:      '#ef5350',
        critical:  '#e53935',
        unknown:   '#78909c',
    };

    async function toggleHealthOverlay() {
        healthOverlayActive = document.getElementById('overlayHealth').checked;
        if (healthOverlayActive) {
            await loadNodeHealthData();
        }
        // Re-render markers with health coloring
        rebuildMarkersFromFeatures();
    }

    async function loadNodeHealthData() {
        try {
            var resp = await fetch(API_BASE + '/api/node-health');
            if (!resp.ok) return;
            var data = await resp.json();
            nodeHealthScores = {};
            if (data.nodes) {
                for (var i = 0; i < data.nodes.length; i++) {
                    var n = data.nodes[i];
                    nodeHealthScores[n.node_id] = { score: n.score, status: n.status };
                }
            }
        } catch (e) {
            console.debug('Node health data unavailable:', e);
        }
    }

    function getHealthColor(nodeId) {
        var hs = nodeHealthScores[nodeId];
        if (!hs) return null;
        return HEALTH_COLORS[hs.status] || HEALTH_COLORS.unknown;
    }

    function rebuildMarkersFromFeatures() {
        renderMarkers();
    }

    // =========================================================================
    // Topology / Link Visualization (GeoJSON from server)
    // =========================================================================

    function toggleTopology() {
        showTopology = document.getElementById('overlayTopology').checked;
        if (showTopology) {
            loadTopologyData();
        } else if (topologyLayer) {
            map.removeLayer(topologyLayer);
            topologyLayer = null;
            document.getElementById('countLinks').textContent = '0';
        }
    }

    async function loadTopologyData() {
        try {
            const resp = await fetch(API_BASE + '/api/topology/geojson');
            if (!resp.ok) return;
            const geojson = await resp.json();
            renderTopologyGeoJSON(geojson);
        } catch (e) {
            console.debug('Topology data unavailable:', e);
        }
    }

    function renderTopologyGeoJSON(geojson) {
        if (topologyLayer) {
            map.removeLayer(topologyLayer);
        }

        topologyLayer = L.geoJSON(geojson, {
            style: function(feature) {
                var props = feature.properties || {};
                var color = props.color || '#6b7280';
                var quality = props.quality || 'Unknown';
                var snr = props.snr;
                var weight = 1.5;
                var opacity = 0.5;

                if (quality === 'Excellent')     { weight = 2.5; opacity = 0.8; }
                else if (quality === 'Good')     { weight = 2.2; opacity = 0.75; }
                else if (quality === 'Marginal') { weight = 2.0; opacity = 0.7; }
                else if (quality === 'Poor')     { weight = 1.8; opacity = 0.65; }
                else if (quality === 'Bad')      { weight = 1.5; opacity = 0.6; }

                return {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    dashArray: (snr != null && snr > 0) ? null : '4 6',
                    interactive: true,
                };
            },
            onEachFeature: function(feature, layer) {
                var props = feature.properties || {};
                var color = props.color || '#6b7280';
                var snr = props.snr;
                var snrText = (snr != null) ? Number(snr).toFixed(1) + ' dB' : 'unknown';
                var quality = props.quality || 'Unknown';
                var network = props.network || '';
                var linkType = props.link_type || '';

                var popup = '<div class="popup-title" style="color:' + color + '">Mesh Link</div>' +
                    '<div class="popup-row"><span class="popup-key">From</span><span class="popup-val">' + esc(props.source || '') + '</span></div>' +
                    '<div class="popup-row"><span class="popup-key">To</span><span class="popup-val">' + esc(props.target || '') + '</span></div>' +
                    '<div class="popup-row"><span class="popup-key">SNR</span><span class="popup-val">' + snrText + '</span></div>' +
                    '<div class="popup-row"><span class="popup-key">Quality</span><span class="popup-val" style="color:' + color + '">' + esc(quality) + '</span></div>';
                if (network) {
                    popup += '<div class="popup-row"><span class="popup-key">Network</span><span class="popup-val">' + esc(network) + '</span></div>';
                }
                if (linkType) {
                    popup += '<div class="popup-row"><span class="popup-key">Type</span><span class="popup-val">' + esc(linkType) + '</span></div>';
                }
                layer.bindPopup(popup);
            },
        }).addTo(map);

        var linkCount = (geojson.features || []).length;
        document.getElementById('countLinks').textContent = linkCount;
    }

    // =========================================================================
    // Node History & Trajectory Visualization
    // =========================================================================

    function toggleTrajectoryPanel() {
        historyPanelOpen = !historyPanelOpen;
        var panel = document.getElementById('historyPanel');
        var checkbox = document.getElementById('overlayTrajectory');
        if (historyPanelOpen) {
            panel.style.display = '';
            checkbox.checked = true;
            loadTrackedNodes();
        } else {
            panel.style.display = 'none';
            checkbox.checked = false;
            clearAllTrajectories();
        }
    }

    async function loadTrackedNodes() {
        var listEl = document.getElementById('historyNodeList');
        try {
            var resp = await fetch(API_BASE + '/api/history/nodes');
            if (!resp.ok) {
                listEl.innerHTML = '<div style="color:#ef5350;font-size:11px;text-align:center;padding:12px">Node history unavailable</div>';
                return;
            }
            var data = await resp.json();
            var nodes = data.nodes || [];
            if (nodes.length === 0) {
                listEl.innerHTML = '<div style="color:#546e7a;font-size:11px;text-align:center;padding:12px">No tracked nodes yet</div>';
                return;
            }
            var html = '';
            for (var i = 0; i < nodes.length; i++) {
                var n = nodes[i];
                var nodeId = n.node_id || n.id || '';
                var count = n.observation_count || n.count || 0;
                var isActive = trajectoryLayers[nodeId] ? ' active' : '';
                html += '<div class="history-node-row" data-node-id="' + esc(nodeId) + '" onclick="toggleTrajectory(this.dataset.nodeId)">' +
                    '<span class="history-node-id">' + esc(nodeId) + '</span>' +
                    '<span class="history-node-count">' + count + ' pts</span>' +
                    '<button class="trajectory-btn' + isActive + '" data-node="' + esc(nodeId) + '">' +
                    (isActive ? 'Hide' : 'Show') + '</button>' +
                    '</div>';
            }
            listEl.innerHTML = html;
        } catch (e) {
            listEl.innerHTML = '<div style="color:#ef5350;font-size:11px;text-align:center;padding:12px">Failed to load history</div>';
        }
    }

    async function toggleTrajectory(nodeId) {
        if (trajectoryLayers[nodeId]) {
            // Remove existing trajectory
            map.removeLayer(trajectoryLayers[nodeId]);
            delete trajectoryLayers[nodeId];
            loadTrackedNodes(); // refresh button states
            return;
        }

        try {
            var resp = await fetch(API_BASE + '/api/nodes/' + encodeURIComponent(nodeId) + '/trajectory');
            if (!resp.ok) {
                showToast('No trajectory data for ' + nodeId, true);
                return;
            }
            var geojson = await resp.json();

            if (!geojson.geometry || !geojson.geometry.coordinates || geojson.geometry.coordinates.length < 2) {
                showToast('Not enough points for trajectory', true);
                return;
            }

            // Render trajectory as a Leaflet polyline with gradient
            var coords = geojson.geometry.coordinates;
            var latlngs = coords.map(function(c) { return [c[1], c[0]]; });

            var trajectoryLine = L.polyline(latlngs, {
                color: '#ffc107',
                weight: 3,
                opacity: 0.8,
                dashArray: '6 4',
                interactive: true,
            });

            // Add start/end markers
            var startMarker = L.circleMarker(latlngs[0], {
                radius: 5, fillColor: '#66bb6a', color: '#fff', weight: 1, fillOpacity: 0.9,
            });
            startMarker.bindPopup('<b>' + esc(nodeId) + '</b><br>Start of trajectory');

            var endMarker = L.circleMarker(latlngs[latlngs.length - 1], {
                radius: 5, fillColor: '#ef5350', color: '#fff', weight: 1, fillOpacity: 0.9,
            });
            endMarker.bindPopup('<b>' + esc(nodeId) + '</b><br>Latest position');

            var props = geojson.properties || {};
            trajectoryLine.bindPopup(
                '<div class="popup-title" style="color:#ffc107">Trajectory: ' + esc(nodeId) + '</div>' +
                '<div class="popup-row"><span class="popup-key">Points</span><span class="popup-val">' + coords.length + '</span></div>' +
                '<div class="popup-row"><span class="popup-key">Network</span><span class="popup-val">' + esc(props.network || '') + '</span></div>'
            );

            // Evict oldest trajectory if at capacity
            var activeIds = Object.keys(trajectoryLayers);
            if (activeIds.length >= MAX_TRAJECTORIES) {
                var evictId = activeIds[0];
                map.removeLayer(trajectoryLayers[evictId]);
                delete trajectoryLayers[evictId];
            }

            var group = L.layerGroup([trajectoryLine, startMarker, endMarker]).addTo(map);
            trajectoryLayers[nodeId] = group;

            // Fit map to trajectory bounds
            map.fitBounds(trajectoryLine.getBounds().pad(0.2));
            loadTrackedNodes(); // refresh button states
        } catch (e) {
            showToast('Failed to load trajectory: ' + e.message, true);
        }
    }

    function clearAllTrajectories() {
        for (var nodeId in trajectoryLayers) {
            if (trajectoryLayers.hasOwnProperty(nodeId)) {
                map.removeLayer(trajectoryLayers[nodeId]);
            }
        }
        trajectoryLayers = {};
    }

    // =========================================================================
    // Service Worker Registration (Offline Tile Caching)
    // =========================================================================

    function registerServiceWorker() {
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw-tiles.js', { scope: '/' })
                .then(function(reg) {
                    console.debug('SW registered:', reg.scope);
                })
                .catch(function(err) {
                    console.debug('SW registration skipped:', err.message);
                });
        }
    }

    // =========================================================================
    // WebSocket Real-Time Client
    // =========================================================================

    function connectWebSocket(port) {
        if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
            return; // Already connected or connecting
        }

        var wsUrl = 'ws://' + window.location.hostname + ':' + port;
        try {
            ws = new WebSocket(wsUrl);
        } catch (e) {
            console.debug('WebSocket not available:', e);
            return;
        }

        ws.onopen = function() {
            console.log('WebSocket connected to', wsUrl);
            wsReconnectDelay = 2000; // Reset backoff on success
            setConnectionStatus('connected', 'Live');
        };

        ws.onmessage = function(event) {
            try {
                var msg = JSON.parse(event.data);
                handleRealtimeMessage(msg);
            } catch (e) {
                console.debug('WebSocket message parse error:', e);
            }
        };

        ws.onclose = function() {
            console.debug('WebSocket closed, reconnecting in', wsReconnectDelay, 'ms');
            ws = null;
            scheduleReconnect(port);
        };

        ws.onerror = function() {
            // onclose will fire after onerror, so reconnect happens there
        };
    }

    function scheduleReconnect(port) {
        if (wsReconnectTimer) clearTimeout(wsReconnectTimer);
        wsReconnectTimer = setTimeout(function() {
            connectWebSocket(port);
        }, wsReconnectDelay);
        // Exponential backoff: 2s, 4s, 8s, 16s, max 30s
        wsReconnectDelay = Math.min(wsReconnectDelay * 2, 30000);
    }

    function handleRealtimeMessage(msg) {
        if (msg.type === 'node.position' && msg.lat && msg.lon && msg.node_id) {
            updateOrAddNode(msg);
        }
        // Other event types (node.info, node.telemetry, node.topology)
        // trigger a lightweight refresh of the affected node's popup if open
        if (msg.type === 'node.info' || msg.type === 'node.telemetry') {
            // These don't move markers, but signal data is fresh
            // Full refresh happens on the next polling cycle
        }
    }

    function updateOrAddNode(msg) {
        var nodeId = msg.node_id;
        var latlng = L.latLng(msg.lat, msg.lon);

        // Check if this node already exists in our markers
        var found = false;
        var groups = [clusterGroup, directGroup];
        for (var g = 0; g < groups.length; g++) {
            if (!groups[g]) continue;
            groups[g].eachLayer(function(layer) {
                if (layer.feature &&
                    layer.feature.properties &&
                    layer.feature.properties.id === nodeId) {
                    // Move existing marker
                    if (layer.setLatLng) {
                        layer.setLatLng(latlng);
                        found = true;
                    }
                }
            });
            if (found) break;
        }

        if (!found) {
            // New node -- add a temporary marker. Full data comes on next poll.
            var marker = L.circleMarker(latlng, {
                radius: 6,
                fillColor: NETWORK_COLORS.meshtastic,
                color: '#fff',
                weight: 1,
                opacity: 0.9,
                fillOpacity: 0.8,
            });
            marker.feature = {
                type: 'Feature',
                properties: { id: nodeId, source: msg.source || 'mqtt' },
                geometry: { type: 'Point', coordinates: [msg.lon, msg.lat] },
            };
            marker.bindPopup('<b>' + esc(nodeId) + '</b><br><i>Real-time update</i>');
            if (useClustering && clusterGroup) {
                clusterGroup.addLayer(marker);
            } else if (directGroup) {
                directGroup.addLayer(marker);
            }
        }
    }

    // =========================================================================
    // =========================================================================
    // Health Check (data staleness indicator)
    // =========================================================================

    async function checkDataHealth() {
        try {
            const resp = await fetch(API_BASE + '/api/health');
            if (!resp.ok) return;
            const health = await resp.json();
            if (health.status === 'critical') {
                setConnectionStatus('error', 'Critical');
                showToast('Health: critical -- sources may be unreachable', true);
            } else if (health.status === 'degraded') {
                setConnectionStatus('error', 'Degraded');
                showToast('Health: degraded -- some sources failing', true);
            }
        } catch (e) {
            // Silently ignore health check failures
        }
    }

    // =========================================================================
    // Auto-refresh
    // =========================================================================

    // Auto-refresh interval (silent -- no toast on auto-refresh, upstream improvement)
    setInterval(function() {
        loadNodeData();
        if (showTopology) loadTopologyData();
    }, 5 * 60 * 1000); // Refresh every 5 minutes

    // Periodic health check (every 2 minutes)
    setInterval(checkDataHealth, 2 * 60 * 1000);

    // =========================================================================
    // Init
    // =========================================================================

    document.addEventListener('DOMContentLoaded', function() {
        initMap();
        registerServiceWorker();
    });
</script>

</body>
</html>
